-- Modern minimal GUI wrapper (entegre edildi)
local function CreateModernGUI()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

    local screenGui = Instance.new("ScreenGui")
    screenGui.ResetOnSpawn = false
    screenGui.Name = "ModernMinimalGUI"
    screenGui.Parent = PlayerGui

    -- Main window
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainWindow"
    mainFrame.Size = UDim2.new(0, 700, 0, 420)
    mainFrame.Position = UDim2.new(0.5, -350, 0.5, -210)
    mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    mainFrame.BackgroundColor3 = Color3.fromRGB(18,18,20)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    mainFrame.ClipsDescendants = true

    local uiCorner = Instance.new("UICorner", mainFrame)
    uiCorner.CornerRadius = UDim.new(0, 12)

    local titleBar = Instance.new("Frame", mainFrame)
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 42)
    titleBar.BackgroundTransparency = 1

    local title = Instance.new("TextLabel", titleBar)
    title.Size = UDim2.new(1, -20, 1, 0)
    title.Position = UDim2.new(0, 12, 0, 0)
    title.BackgroundTransparency = 1
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Font = Enum.Font.GothamBold
    title.Text = "Ro-Ghoul"
    title.TextSize = 18
    title.TextColor3 = Color3.fromRGB(230,230,230)

    -- Left sidebar (tabs)
    local sidebar = Instance.new("Frame", mainFrame)
    sidebar.Name = "Sidebar"
    sidebar.Size = UDim2.new(0, 150, 1, -52)
    sidebar.Position = UDim2.new(0, 12, 0, 50)
    sidebar.BackgroundTransparency = 1

    local sidebarLayout = Instance.new("UIListLayout", sidebar)
    sidebarLayout.SortOrder = Enum.SortOrder.LayoutOrder
    sidebarLayout.Padding = UDim.new(0, 8)
    sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    sidebarLayout.VerticalAlignment = Enum.VerticalAlignment.Top

    local content = Instance.new("Frame", mainFrame)
    content.Name = "Content"
    content.Position = UDim2.new(0, 174, 0, 50)
    content.Size = UDim2.new(1, -186, 1, -62)
    content.BackgroundTransparency = 1
    content.ClipsDescendants = true

    local contentUIList = Instance.new("UIListLayout", content)
    contentUIList.SortOrder = Enum.SortOrder.LayoutOrder
    contentUIList.Padding = UDim.new(0, 8)

    -- simple divider style helper
    local function MakeDivider(parent)
        local d = Instance.new("Frame", parent)
        d.Size = UDim2.new(1, 0, 0, 1)
        d.BackgroundColor3 = Color3.fromRGB(60,60,65)
        d.BorderSizePixel = 0
        return d
    end

    -- storage for api objects
    local windowAPI = {}
    local tabs = {}

    -- utilities to create minimal components
    local function createLabel(text, parent)
        local lab = Instance.new("TextLabel", parent)
        lab.Size = UDim2.new(1, 0, 0, 20)
        lab.BackgroundTransparency = 1
        lab.TextXAlignment = Enum.TextXAlignment.Left
        lab.Font = Enum.Font.Gotham
        lab.TextSize = 14
        lab.Text = text or ""
        lab.TextColor3 = Color3.fromRGB(220,220,220)
        return lab
    end

    local function createButton(text, parent)
        local btn = Instance.new("TextButton", parent)
        btn.Size = UDim2.new(1, 0, 0, 28)
        btn.BackgroundColor3 = Color3.fromRGB(34,34,36)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamSemibold
        btn.TextSize = 14
        btn.Text = text or "Button"
        btn.TextColor3 = Color3.fromRGB(230,230,230)
        local c = Instance.new("UICorner", btn)
        c.CornerRadius = UDim.new(0,6)
        return btn
    end

    local function createToggle(text, parent, initial)
        local frame = Instance.new("Frame", parent)
        frame.Size = UDim2.new(1, 0, 0, 28)
        frame.BackgroundTransparency = 1

        local label = Instance.new("TextLabel", frame)
        label.Size = UDim2.new(0.82, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Font = Enum.Font.Gotham
        label.TextSize = 14
        label.Text = text or ""
        label.TextColor3 = Color3.fromRGB(220,220,220)

        local toggle = Instance.new("TextButton", frame)
        toggle.Size = UDim2.new(0.16, 0, 0.75, 0)
        toggle.Position = UDim2.new(0.84, 0, 0.125, 0)
        toggle.BackgroundColor3 = initial and Color3.fromRGB(80,200,120) or Color3.fromRGB(50,50,55)
        toggle.BorderSizePixel = 0
        toggle.Text = initial and "ON" or "OFF"
        toggle.Font = Enum.Font.GothamBold
        toggle.TextSize = 12
        toggle.TextColor3 = Color3.fromRGB(240,240,240)
        local c = Instance.new("UICorner", toggle)
        c.CornerRadius = UDim.new(0,6)
        return frame, toggle
    end

    local function createSlider(labelText, parent, min, max, readonly)
        local frame = Instance.new("Frame", parent)
        frame.Size = UDim2.new(1, 0, 0, 40)
        frame.BackgroundTransparency = 1

        local label = Instance.new("TextLabel", frame)
        label.Size = UDim2.new(1, 0, 0, 16)
        label.BackgroundTransparency = 1
        label.Text = labelText or ""
        label.Font = Enum.Font.Gotham
        label.TextSize = 13
        label.TextColor3 = Color3.fromRGB(220,220,220)
        label.TextXAlignment = Enum.TextXAlignment.Left

        local sliderFrame = Instance.new("Frame", frame)
        sliderFrame.Position = UDim2.new(0, 0, 0, 18)
        sliderFrame.Size = UDim2.new(1, 0, 0, 18)
        sliderFrame.BackgroundColor3 = Color3.fromRGB(36,36,38)
        sliderFrame.BorderSizePixel = 0
        local c = Instance.new("UICorner", sliderFrame)
        c.CornerRadius = UDim.new(0,6)

        local fill = Instance.new("Frame", sliderFrame)
        fill.Size = UDim2.new(0, 0, 1, 0)
        fill.BackgroundColor3 = Color3.fromRGB(80,160,255)
        fill.BorderSizePixel = 0
        local fc = Instance.new("UICorner", fill)
        fc.CornerRadius = UDim.new(0,6)

        local valueLabel = Instance.new("TextLabel", sliderFrame)
        valueLabel.AnchorPoint = Vector2.new(1, 0.5)
        valueLabel.Position = UDim2.new(1, -6, 0.5, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Size = UDim2.new(0, 50, 0, 14)
        valueLabel.Font = Enum.Font.Gotham
        valueLabel.TextSize = 12
        valueLabel.TextColor3 = Color3.fromRGB(220,220,220)
        valueLabel.Text = tostring(min or 0)

        -- return API
        local obj = {
            Frame = frame,
            Set = function(v)
                if not min or not max then
                    valueLabel.Text = tostring(v)
                    fill.Size = UDim2.new(0, 0, 1, 0)
                    return
                end
                local clamped = math.clamp(v, min, max)
                local pct = (clamped - min) / (max - min)
                fill.Size = UDim2.new(pct, 0, 1, 0)
                valueLabel.Text = tostring(clamped)
            end
        }

        -- interaction if not readonly
        if not readonly and min and max then
            sliderFrame.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    local function update(input2)
                        local abs = input2.Position.X - sliderFrame.AbsolutePosition.X
                        local pct = math.clamp(abs/sliderFrame.AbsoluteSize.X, 0, 1)
                        local val = min + pct * (max - min)
                        obj.Set(math.floor(val + 0.5))
                        if obj._callback then obj._callback(math.floor(val + 0.5)) end
                    end
                    update(input)
                    local conn
                    conn = game:GetService("UserInputService").InputChanged:Connect(function(i)
                        if i.UserInputType == Enum.UserInputType.MouseMovement then
                            update(i)
                        end
                    end)
                    local upConn
                    upConn = game:GetService("UserInputService").InputEnded:Connect(function(i)
                        if i.UserInputType == Enum.UserInputType.MouseButton1 then
                            conn:Disconnect()
                            upConn:Disconnect()
                        end
                    end)
                end
            end)
        end

        function obj:OnChanged(fn) obj._callback = fn end
        return obj
    end

    local function createDropdown(labelText, parent)
        local frame = Instance.new("Frame", parent)
        frame.Size = UDim2.new(1, 0, 0, 28)
        frame.BackgroundTransparency = 1

        local label = Instance.new("TextLabel", frame)
        label.Size = UDim2.new(0.7, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Font = Enum.Font.Gotham
        label.TextSize = 14
        label.Text = labelText or ""
        label.TextColor3 = Color3.fromRGB(220,220,220)

        local btn = Instance.new("TextButton", frame)
        btn.Size = UDim2.new(0.3, -6, 1, 0)
        btn.Position = UDim2.new(0.7, 6, 0, 0)
        btn.BackgroundColor3 = Color3.fromRGB(36,36,38)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.Gotham
        btn.TextSize = 13
        btn.Text = "Select"
        btn.TextColor3 = Color3.fromRGB(220,220,220)
        local c = Instance.new("UICorner", btn)
        c.CornerRadius = UDim.new(0,6)

        local options = {}
        local dropdownFrame
        local open = false

        local function buildDropdown()
            if dropdownFrame and dropdownFrame.Parent then dropdownFrame:Destroy() end
            dropdownFrame = Instance.new("ScrollingFrame", content)
            dropdownFrame.Size = UDim2.new(0, 220, 0, math.clamp(#options * 26, 0, 180))
            dropdownFrame.Position = UDim2.new(0, 0, 0, 0)
            dropdownFrame.BorderSizePixel = 0
            dropdownFrame.BackgroundColor3 = Color3.fromRGB(22,22,24)
            dropdownFrame.CanvasSize = UDim2.new(0, 0)
            dropdownFrame.ScrollBarThickness = 6
            dropdownFrame.Visible = false
            dropdownFrame.ZIndex = 50
            local list = Instance.new("UIListLayout", dropdownFrame)
            list.SortOrder = Enum.SortOrder.LayoutOrder
            list.Padding = UDim.new(0, 4)

            for i, opt in ipairs(options) do
                local optBtn = Instance.new("TextButton", dropdownFrame)
                optBtn.Size = UDim2.new(1, -8, 0, 24)
                optBtn.Position = UDim2.new(0, 4, 0, (i-1)*28)
                optBtn.BackgroundColor3 = Color3.fromRGB(34,34,36)
                optBtn.BorderSizePixel = 0
                optBtn.Font = Enum.Font.Gotham
                optBtn.TextSize = 13
                optBtn.Text = opt
                optBtn.TextColor3 = Color3.fromRGB(230,230,230)
                local uc = Instance.new("UICorner", optBtn)
                uc.CornerRadius = UDim.new(0,6)
                optBtn.MouseButton1Click:Connect(function()
                    btn.Text = opt
                    if frame._callback then frame._callback(opt) end
                    dropdownFrame.Visible = false
                    open = false
                end)
            end
        end

        btn.MouseButton1Click:Connect(function()
            open = not open
            if open then
                -- position dropdown near content and show
                buildDropdown()
                dropdownFrame.Position = UDim2.new(0, 174, 0, 50) -- simplistic placement
                dropdownFrame.Visible = true
            else
                if dropdownFrame then dropdownFrame.Visible = false end
            end
        end)

        local obj = {}
        function obj:Add(option)
            table.insert(options, option)
        end
        function obj:OnChange(fn) frame._callback = fn end
        return obj
    end

    local function createConsole(parent, initial)
        local frame = Instance.new("Frame", parent)
        frame.Size = UDim2.new(1, 0, 0, 120)
        frame.BackgroundTransparency = 1

        local textBox = Instance.new("TextBox", frame)
        textBox.Size = UDim2.new(1, 0, 1, 0)
        textBox.ClearTextOnFocus = false
        textBox.TextWrapped = true
        textBox.Text = initial or ""
        textBox.Font = Enum.Font.Gotham
        textBox.TextSize = 13
        textBox.TextColor3 = Color3.fromRGB(230,230,230)
        textBox.BackgroundColor3 = Color3.fromRGB(30,30,32)
        textBox.BorderSizePixel = 0
        local c = Instance.new("UICorner", textBox)
        c.CornerRadius = UDim.new(0,8)

        local obj = {}
        function obj:Set(txt) textBox.Text = txt end
        function obj:Get() return textBox.Text end
        function obj:OnChange(fn) textBox:GetPropertyChangedSignal("Text"):Connect(function() fn(textBox.Text) end) end
        return obj
    end

    -- API: window creation
    function windowAPI:AddTab(name)
        local tabBtn = createButton(name, sidebar)
        tabBtn.Size = UDim2.new(1, -6, 0, 30)
        tabBtn.BackgroundColor3 = Color3.fromRGB(28,28,30)
        tabBtn.Font = Enum.Font.GothamSemibold
        tabBtn.TextSize = 14
        tabBtn.AutoButtonColor = true

        local tabContent = Instance.new("Frame", content)
        tabContent.Size = UDim2.new(1, 0, 1, 0)
        tabContent.BackgroundTransparency = 1
        tabContent.Visible = false

        local tabLayout = Instance.new("UIListLayout", tabContent)
        tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
        tabLayout.Padding = UDim.new(0, 8)

        local tabObj = {}

        function tabObj:AddLabel(txt)
            local l = createLabel(txt, tabContent)
            return {label = l}
        end

        function tabObj:AddButton(txt, fn)
            local b = createButton(txt, tabContent)
            b.MouseButton1Click:Connect(function() pcall(fn) end)
            -- provide Text property so external code can assign to b.Text
            return b
        end

        function tabObj:AddDropdown(txt, fn)
            local dd = createDropdown(txt, tabContent)
            dd.OnChange(fn)
            return dd
        end

        function tabObj:AddSwitch(txt, fn)
            local container, toggle = createToggle(txt, tabContent, false)
            local state = false
            toggle.MouseButton1Click:Connect(function()
                state = not state
                toggle.BackgroundColor3 = state and Color3.fromRGB(80,200,120) or Color3.fromRGB(50,50,55)
                toggle.Text = state and "ON" or "OFF"
                pcall(fn, state)
            end)
            local api = {}
            function api:Set(v)
                state = v and true or false
                toggle.BackgroundColor3 = state and Color3.fromRGB(80,200,120) or Color3.fromRGB(50,50,55)
                toggle.Text = state and "ON" or "OFF"
            end
            return api
        end

        function tabObj:AddSlider(txt, fn, opts)
            opts = opts or {}
            local min = opts.min
            local max = opts.max
            local readonly = opts.readonly
            local slider = createSlider(txt, tabContent, min, max, readonly)
            if fn then slider:OnChanged(fn) end
            return slider
        end

        function tabObj:AddConsole(opt)
            return createConsole(tabContent, opt and opt.source and opt.source == "Text" and "" or "")
        end

        function tabObj:Show()
            -- hide others
            for i,v in pairs(tabs) do
                v.Content.Visible = false
            end
            tabContent.Visible = true
        end

        tabObj.Content = tabContent
        tabs[name] = tabObj

        tabBtn.MouseButton1Click:Connect(function()
            tabObj:Show()
        end)

        return tabObj
    end

    -- instantiate minimal default structure and return API
    return windowAPI, mainFrame
end

-- create and use modern GUI
local gui, _mainFrame = CreateModernGUI()
-- keep API compatibility: AddWindow returns an object with AddTab method
-- original script calls :AddWindow(...). Emulate that:
local function AddWindow(title, opts)
    -- set title if given
    pcall(function() 
        -- try to set title if gui created frame exists
        -- This wrapper created title internally already; nothing else needed.
    end)
    return {
        AddTab = function(name) return gui:AddTab(name) end
    }
end

-- replace original loader call with our AddWindow
local gui = AddWindow("Ro-Ghoul", {
    main_color = Color3.fromRGB(0,0,0),
    min_size = Vector2.new(373, 340),
    can_resize = false
})

-- === ORIGINAL SCRIPT BEGINS (touched only GUI creation above) ===

local get = setmetatable({}, {
    __index = function(a, b)
        return game:GetService(b) or game[b]
    end
})

local tab1, tab2, tab3, tab4 = gui:AddTab("Main"), gui:AddTab("Farm Options"), gui:AddTab("Trainer"), gui:AddTab("Misc")
local btn, btn2, btn3, key, nmc, trainers, labels
local findobj, findobjofclass, waitforobj, fire, invoke = get.FindFirstChild, get.FindFirstChildOfClass, get.WaitForChild, Instance.new("RemoteEvent").FireServer, Instance.new("RemoteFunction").InvokeServer
local player = get.Players.LocalPlayer

repeat wait() until player:FindFirstChild("PlayerFolder")

local team, remotes, stat = player.PlayerFolder.Customization.Team.Value, get.ReplicatedStorage.Remotes, player.PlayerFolder.StatsFunction
local oldtick, farmtick = 0, 0
local camera = workspace.CurrentCamera
local myData = loadstring(game:HttpGet("https://raw.githubusercontent.com/z4gs/scripts/master/Settings.lua"))()("Ro-Ghoul Autofarm", {
    Skills = {
        E = false,
        F = false,
        C = false,
        R = false
    },
    Boss = {
        ["Gyakusatsu"] = false,
        ["Eto Yoshimura"] = false,
        ["Koutarou Amon"] = false,
        ["Nishiki Nishio"] = false
    },
    DistanceFromNpc = 5,
    DistanceFromBoss = 8,
    TeleportSpeed = 150,
    ReputationFarm = false,
    ReputationCashout = false,
    AutoKickWhitelist = ""
})

local array = {
    boss = {
        ["Gyakusatsu"] = 1250,
        ["Eto Yoshimura"] = 1250,
        ["Koutarou Amon"] = 750,
        ["Nishiki Nishio"] = 250
    },

    npcs = {["Aogiri Members"] = "GhoulSpawns", Investigators = "CCGSpawns", Humans = "HumanSpawns"},

    stages = {"One", "Two", "Three", "Four", "Five", "Six"},

    skills = {
        E = player.PlayerFolder.Special1CD,
        F = player.PlayerFolder.Special3CD,
        C = player.PlayerFolder.SpecialBonusCD,
        R = player.PlayerFolder.Special2CD
    }
}

tab1:AddLabel("Target")

local drop = tab1:AddDropdown("Select", function(opt)
    array.targ = array.npcs[opt]
end)

btn = tab1:AddButton("Start", function()
    if not array.autofarm then
        if key then
            btn.Text, array.autofarm = "Stop", true
            local farmtick = tick()
            while array.autofarm do
                labels("tfarm", "Time elapsed: "..os.date("!%H:%M:%S", tick() - farmtick))
                wait(1)
            end
        else
            player:Kick("Failed to get the Remote key, please try to execute the script again")
        end
    else
        btn.Text, array.autofarm, array.died = "Start", false, false
    end
end)

local function format(number)
    local i, k, j = tostring(number):match("(%-?%d?)(%d*)(%.?.*)")
    return i..k:reverse():gsub("(%d%d%d)", "%1,"):reverse()..j
end

labels = setmetatable({
    text = {label = tab1:AddLabel("")},
    tfarm = {label = tab1:AddLabel("")},
    space = {label = tab1:AddLabel("")},
    Quest = {prefix = "Current Quest: ", label = tab1:AddLabel("Current Quest: None")},
    Yen = {prefix = "Yen: ", label = tab1:AddLabel("Yen: 0"), value = 0, oldval = player.PlayerFolder.Stats.Yen.Value},
    RC = {prefix = "RC: ", label = tab1:AddLabel("RC: 0"), value = 0, oldval = player.PlayerFolder.Stats.RC.Value},
    Kills = {prefix = "Kills: ", label = tab1:AddLabel("Kills: 0"), value = 0} 
}, {
    __call = function (self, typ, newv, oldv)
        if typ and newv then
            local object = self[typ]
            if type(newv) == "number" then
                object.value = object.value + newv
                object.label.Text = object.prefix..format(object.value)
                if oldv then
                    object.oldval = oldv
                end
            elseif object.prefix then
                object.label.Text = object.prefix..newv
            else
                object.label.Text = newv
            end
            return
        end
        for i,v in pairs(labels) do
            v.value = 0
            v.label.Text = v.prefix.."0"
        end
    end
})

local function getLabel(la)
    return labels[la].value and labels[la].value or labels[la].label.Text
end

btn3 = tab1:AddButton("Reset", function() labels() end)

if team == "CCG" then tab2:AddLabel("Quinque Stage") else tab2:AddLabel("Kagune Stage") end

local drop2 = tab2:AddDropdown("[ 1 ]", function(opt)
    array.stage = array.stages[tonumber(opt)]
end)

array.stage = "One"

tab2:AddSwitch("Reputation Farm", function(bool) 
    myData.ReputationFarm = bool
end):Set(myData.ReputationFarm)

tab2:AddSwitch("Auto Reputation Cashout", function(bool)
    myData.ReputationCashout = bool
end):Set(myData.ReputationCashout)

for i,v in pairs(array.boss) do
    tab2:AddSwitch(i.." Boss Farm ".."(".."lvl "..v.."+)", function(bool)
        myData.Boss[i] = bool
    end):Set(myData.Boss[i])
end

tab2:AddSlider("TP Speed", function(x)
    myData.TeleportSpeed = x
end, {min = 90, max = 250}):Set(45)

tab2:AddSlider("Distance from NPC", function(x)
    myData.DistanceFromNpc = x * -1
end, {min = 0, max = 8}):Set(65)

tab2:AddSlider("Distance from Bosses", function(x)
    myData.DistanceFromBoss = x * -1
end, {min = 0, max = 15}):Set(55)

labels.p = {label = tab3:AddLabel("Current trainer: "..player.PlayerFolder.Trainers[team.."Trainer"].Value)}

local progress = tab3:AddSlider("Progress", nil, {min = 0, max = 100, readonly = true})

progress:Set(player.PlayerFolder.Trainers[player.PlayerFolder.Trainers[team.."Trainer"].Value].Progress.Value)

player.PlayerFolder.Trainers[team.."Trainer"].Changed:connect(function()
    labels("p", "Current trainer: "..player.PlayerFolder.Trainers[team.."Trainer"].Value)
    progress:Set(player.PlayerFolder.Trainers[player.PlayerFolder.Trainers[team.."Trainer"].Value].Progress.Value)
end)

btn2 = tab3:AddButton("Start", function()
    if not array.trainer then
        array.trainer, btn2.Text = true, "Stop"
        local connection, time

        while array.trainer do
            if connection and connection.Connected then
                connection:Disconnect()
            end
            
            local tkey, result

            connection = player.Backpack.DescendantAdded:Connect(function(obj)
                if tostring(obj) == "TSCodeVal" and obj:IsA("StringValue") then
                    tkey = obj.Value
                end
            end)
            
            result = invoke(remotes.Trainers.RequestTraining)

            if result == "TRAINING" then
                for i,v in pairs(workspace.TrainingSessions:GetChildren()) do
                    if waitforobj(v, "Player").Value == player then
                        fire(waitforobj(v, "Comm"), "Finished", tkey, false)
                        break
                    end
                end
            elseif result == "TRAINING COMPLETE" then
                labels("time", "Switching to other trainer...")
                for i,v in pairs(player.PlayerFolder.Trainers:GetDescendants()) do
                    if table.find(trainers, v.Name) and findobj(v, "Progress") and tonumber(v.Progress.Value) < 100 and tonumber(player.PlayerFolder.Trainers[player.PlayerFolder.Trainers[team.."Trainer"].Value].Progress.Value) == 100 then
                        invoke(remotes.Trainers.ChangeTrainer, v.Name)
                        wait(1.5)
                    end
                end
            else
                labels("time", "Time until the next training: "..result)
            end
            wait(1)
        end
        labels("time", "")
    else
        array.trainer, btn2.Text = false, "Start"
    end
end)

labels.time = {label = tab3:AddLabel("")}

tab4:AddSwitch("Auto add kagune/quinque stats", function(bool) array.weapon = bool end)
tab4:AddSwitch("Auto add durability stats", function(bool) array.dura = bool end)
tab4:AddSwitch("Auto kick", function(bool) array.kick = bool end)
tab4:AddLabel("Auto kick whitelist (type 1 name per line)")

local console = tab4:AddConsole({
    ["y"] = 50,
    ["source"] = "Text",
})

console:Set(myData.AutoKickWhitelist)

console:OnChange(function(newtext)
    myData.AutoKickWhitelist = newtext
end)

for i,v in pairs(array.skills) do
    tab4:AddSwitch("Auto use "..i.." skill (on bosses)", function(bool)
        myData.Skills[i] = bool
    end):Set(myData.Skills[i])
end

do
    local count = 0
    for i,v in pairs(player.PlayerGui.HUD.StagesFrame.InfoScroll:GetChildren()) do
        if v.ClassName == "Frame" and v.Name ~= "Example" then
            count = count + 1
            drop2:Add(count)
        end
    end
end

for i,v in pairs(array.npcs) do drop:Add(i) end

tab1:Show()

local function tp(pos)
    if array.died then
        player.Character.HumanoidRootPart.CFrame = pos
        array.died = false
        return
    end

    local val = Instance.new("CFrameValue")
    val.Value = player.Character.HumanoidRootPart.CFrame

    local tween = game:GetService("TweenService"):Create(
        val, 
        TweenInfo.new((player.Character.HumanoidRootPart.Position - pos.p).magnitude / myData.TeleportSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), 
        {Value = pos}
    )

    tween:Play()

    local completed
    tween.Completed:Connect(function()
        completed = true
    end)

    while not completed do
        if array.found or not array.autofarm or player.Character.Humanoid.Health <= 0 then tween:Cancel() break end
        player.Character.HumanoidRootPart.CFrame = val.Value
        task.wait()
    end

    val:Destroy()
end

local function getNPC()
    local nearestnpc, nearest = nil, math.huge

    if myData.Boss.Gyakusatsu and tonumber(player.PlayerFolder.Stats.Level.Value) > array.boss["Gyakusatsu"] and findobj(workspace.NPCSpawns["GyakusatsuSpawn"], "Gyakusatsu") then
        local lowesthealth, lowestNpcModel = math.huge, nil

        for i,v in pairs(workspace.NPCSpawns["GyakusatsuSpawn"]:GetChildren()) do
            if v.Name ~= "Mob" and findobj(v, "Humanoid") and v.Humanoid.Health < lowesthealth then
                lowesthealth = v.Humanoid.Health
                lowestNpcModel = v
            end
        end

        if not lowestNpcModel then
            return workspace.NPCSpawns.GyakusatsuSpawn.Gyakusatsu
        end
        
        return lowestNpcModel
    end

    for i,v in pairs(workspace.NPCSpawns:GetChildren()) do
        local npc = findobjofclass(v, "Model")

        if npc and findobj(npc, "Head") and not findobj(npc, "AC") then
            if npc.Parent.Name == array.targ then
                local magnitude = (npc.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude

                if magnitude < nearest then
                    nearestnpc, nearest = npc, magnitude
                end
            elseif myData.Boss[npc.Name] and tonumber(player.PlayerFolder.Stats.Level.Value) >= array.boss[npc.Name] then
                return npc
            end
        end
    end
    return nearestnpc
end

local function getQuest(typ)
    labels("text", "Moving to quest NPC")

    local npc = team == "Ghoul" and workspace.Anteiku.Yoshimura or workspace.CCGBuilding.Yoshitoki

    tp(npc.HumanoidRootPart.CFrame)
    invoke(game:GetService("ReplicatedStorage").Remotes.Ally.AllyInfo)
    wait()
    fireclickdetector(npc.TaskIndicator.ClickDetector)

    if array.autofarm and not array.died and (npc.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude <= 20 then
        if typ then 
            labels("text", "Getting quest...")
            invoke(remotes[npc.Name].Task)
            invoke(remotes[npc.Name].Task)
            local quest = waitforobj(player.PlayerFolder.CurrentQuest.Complete, "Aogiri Member")
            labels("Quest", ("%c/%c"):format("0", quest:WaitForChild("Max").Value))
            quest.Changed:Connect(function(change) 
                labels("Quest", ("%c/%c"):format(change, quest.Max.Value)) 
            end)
        else
            labels("text", "Withdrawing reputation")
            invoke(remotes.ReputationCashOut)
            oldtick = tick()
        end
    end
end

local function collect(npc)
    local timer = tick()
    local model = waitforobj(npc, npc.Name.." Corpse", 2)
    local clickpart = waitforobj(model, "ClickPart", 2)

    player.Character.HumanoidRootPart.CFrame = clickpart.CFrame * CFrame.new(0,1.7,0)

    waitforobj(clickpart, "")
    repeat
        if tick() - timer > 4 then
            break
        end
        player.Character.Humanoid:MoveTo(clickpart.Position)
        wait()
        fireclickdetector(clickpart[""], 1)
    until not model.Parent.Parent or not findobj(model, "ClickPart") or not array.autofarm or player.Character.Humanoid.Health <= 0
end

local function pressKey(topress)
    fire(player.Character.Remotes.KeyEvent, key, topress, "Down", player:GetMouse().Hit, nil, workspace.Camera.CFrame)
end

player.PlayerFolder.Stats.RC.Changed:Connect(function(value)
    if array.autofarm then
        labels("RC", value - labels.RC.oldval, value)
    end
end)

player.PlayerFolder.Stats.Yen.Changed:Connect(function(value)
    if array.autofarm then
        labels("Yen", value - labels.Yen.oldval, value)
    end
end)

getconnections(player.Idled)[1]:Disable()

get.Players.PlayerAdded:Connect(function(plr)
    if array.kick then
        local splittedarray = console:Get():split("\n")

        if not table.find(splittedarray, plr.Name) then
            player:Kick("Player joined, name: "..plr.Name) 
        end
    end
end)

player.PlayerFolder.Trainers[player.PlayerFolder.Trainers[team.."Trainer"].Value].Progress.Changed:Connect(function(c)
    progress:Set(tonumber(c))
end)

coroutine.wrap(function()
    while wait() do
        if tonumber(player.PlayerFolder.Stats.Focus.Value) > 0 then
            if array.weapon then
                invoke(stat, "Focus", "WeaponAddButton", 1)
            end
            if array.dura then
                invoke(stat, "Focus", "DurabilityAddButton", 1)
            end
        end
    end
end)()

-- remote Key grabber + grab updated trainers table
do
    fireclickdetector(workspace.TrainerModel.ClickIndicator.ClickDetector)
    waitforobj(waitforobj(player.PlayerGui, "TrainersGui"), "TrainersGuiScript")
    player.PlayerGui.TrainersGui:Destroy()

    repeat 
        for i,v in pairs(getgc(true)) do
            if not key and type(v) == "function" and getinfo(v).source:find(".ClientControl") then
                for i2,v2 in pairs(getconstants(v)) do
                    if v2 == "KeyEvent" then
                        local keyfound = getconstant(v, i2 + 1)
                        if #keyfound >= 100 then
                            key = keyfound
                            break
                        end
                    end
                end
            elseif type(v) == "table" and ((table.find(v, "(S1) Kureo Mado") and team == "CCG") or (table.find(v, "(S1) Ken Kaneki"))) then
                trainers = v
            end
        end
        wait()
    until key
end

-- auto farm
while true do
    if array.autofarm then
        pcall(function()
            if player.Character.Humanoid.Health > 0 and player.Character.HumanoidRootPart and player.Character.Remotes.KeyEvent then
                if not findobj(player.Character, "Kagune") and not findobj(player.Character, "Quinque")  then
                    pressKey(array.stage)
                end
                if myData.ReputationFarm and (not findobj(player.PlayerFolder.CurrentQuest.Complete, "Aogiri Member") or player.PlayerFolder.CurrentQuest.Complete["Aogiri Member"].Value == player.PlayerFolder.CurrentQuest.Complete["Aogiri Member"].Max.Value) then
                    getQuest(true)
                    return
                elseif myData.ReputationCashout and tick() - oldtick > 7200 then
                    getQuest()
                end

                local npc = getNPC()

                if npc then
                    array.found = false
                    local reached = false

                    coroutine.wrap(function()
                        while not reached do
                            if npc ~= getNPC() then
                                array.found = true
                                break
                            end
                            wait()
                        end
                    end)()

                    labels("text", "Moving to: "..npc.Name)

                    if myData.Boss[npc.Name] or npc.Parent.Name == "GyakusatsuSpawn" then
                        tp(npc.HumanoidRootPart.CFrame * CFrame.Angles(math.rad(90),0,0) + Vector3.new(0,myData.DistanceFromBoss,0))
                    else
                        tp(npc.HumanoidRootPart.CFrame + npc.HumanoidRootPart.CFrame.lookVector * myData.DistanceFromNpc)
                    end

                    labels("text", "Killing: "..npc.Name)
                    
                    reached = true

                    if not array.found then
                        while findobj(findobj(npc.Parent, npc.Name), "Head") and player.Character.Humanoid.Health > 0 and array.autofarm do
                            if not findobj(player.Character, "Kagune") and not findobj(player.Character, "Quinque")  then
                                pressKey(array.stage)
                            end
                            if myData.Boss[npc.Name] or npc.Parent.Name == "GyakusatsuSpawn" then 
                                for x,y in pairs(myData.Skills) do
                                    if player.PlayerFolder.CanAct.Value and y and array.skills[x].Value ~= "DownTime" then
                                        pressKey(x)
                                    end
                                end
                                player.Character.HumanoidRootPart.CFrame = npc.HumanoidRootPart.CFrame * CFrame.Angles(math.rad(90),0,0) + Vector3.new(0,myData.DistanceFromBoss ,0)
                            else
                                player.Character.HumanoidRootPart.CFrame = npc.HumanoidRootPart.CFrame + npc.HumanoidRootPart.CFrame.lookVector * myData.DistanceFromNpc 
                            end
                            if player.PlayerFolder.CanAct.Value then
                                pressKey("Mouse1")
                            end
                            task.wait()
                        end

                        if npc.Name == "Gyakusatsu" then
                            player.Character.Humanoid.Health = 0
                        end

                        if array.autofarm and player.Character.Humanoid.Health > 0 then
                            labels("Kills", 1)
                            if npc.Name ~= "Eto Yoshimura" and not findobj(npc.Parent, "Gyakusatsu") and npc.Name ~= "Gyakusatsu" then  
                                labels("text", "Collecting corpse...")
                                collect(npc)
                            end
                        end
                    end
                else
                    labels("text", "Target not found, waiting...")
                end
            else
                labels("text", "Waiting for character to respawn")
                array.died = true
            end
        end)
    else
        labels("text", "")
    end
    wait()
end
